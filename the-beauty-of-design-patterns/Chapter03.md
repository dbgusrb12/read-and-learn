# 03. 설계 원칙

## 3.1 단일 책임 원칙

`단일 책임 원칙 (Sindle Responsibility Principle, SRP)`이란 클래스와 모듈은 하나의 책임 또는 기능만을 가지고 있어야 한다는 설계 원칙이다.

거대하고 포괄적인 클래스를 설계하는 대신, 작은 단위와 단일 기능을 가진 클래스를 설계해야 한다.  
다시 말해, 클래스에 비즈니스와 관련 없는 기능이 두 개 이상 포함되어 있으면 책임이 단일하지 않으므로, 단일 기능을 가진 여러 개의 작은 클래스로 분할되어야 한다.

### 클래스에 단일 책임이 있는지 판단하는 방법

클래스에 단일 책임이 있는지를 명가하기 위한 명확하고 정량화할 수 있는 표준은 존재하지 않는다.  
실제로 소프트웨어를 개발할 때는 과도하게 너무 세분화하여 설계할 필요는 없고,  
사업이 발전하면서 클래스에 기능이 추가되고, 코드가 복잡해지면서 거대해진 클래스를 여러 개의 세분화된 클래스로 나누면 된다.

단일 책임 여부를 결정하기 위해 사용되는 몇 가지 결정 원칙은 다음과 같다.
- 클래스에 코드, 함수 또는 속성이 너무 많아 코드의 가독성과 유지보수성에 영향을 미치는 경우 클래스 분할을 고려해야 한다.
- 클래스가 너무 과하게 다른 클래스에 의존한다면, 높은 응집도와 낮은 결합도의 코드 설계 사상에 부합하지 않으므로 클래스 분할을 고려해야 한다.
- 클래스에 `private` 메서드가 너무 많은 경우 `private` 메서드를 새로운 클래스로 분리하고  
  더 많은 클래스에서 사용할 수 있도록 `public` 메서드로 설정하여 코드의 재사용성을 향상시켜야한다.
- 클래스의 이름을 비즈니스적으로 정확하게 지정하기 어렵거나 `Manager`, `Context` 처럼 일반적인 단어가 아니면 클래스의 이름을 정의하기 어려울 경우,  
  클래스의 책임 정의가 충분히 명확하지 않음을 의미할 수 있다.
- 클래스의 많은 메서드가 여러 속성 중 일부에서만 작동하는 경우 이러한 속성과 해당 메서드를 분할하는 것을 고려할 수 있다.

### 클래스의 책임이 가능한 한 자세하게 설명되어 있는지 여부

클래스를 최대한 작게 나누는것만이 꼭 정답은 아니다.  
책임을 나눔으로써 코드의 응집력이 낮아지게 되면 코드의 유지보수성이 낮아지는 결과를 초래할 수 있다.

설계 원칙을 적용하든 디자인 패턴을 적용하든 그 목표는 코드의 가독성, 확장성, 재사용성, 유지보수성을 향상시키는 것이다.  
어떤 설계 원칙을 적용하는 것이 타당한지를 판단할 때 이 목표를 최종 평가 기준으로 삼아야한다.

## 3.2 개방 폐쇄 원칙

`개방 폐쇄 원칙 (Open-Closed Principle, OCP)`이란 확장에는 열려있고, 수정에는 닫혀있어야 한다는 설계 원칙이다.

SOLID 원칙 중 가장 이해하기 어렵고, 마스터하기 어려우며 가장 유용한 원칙이기도하다.  
그 이유는 코드를 변경할 때 그 결과를 `확장`으로 보아야 하는지, `수정`으로 보아야 하는지 명확하게 구분하기 어렵지 때문이다.

### 확장할 때는 개방, 수정할 때는 폐쇄

모듈, 클래스, 함수와 같은 소프트웨어의 단위들은 확장을 위해 개방되어야 하지만 수정을 위해서는 폐쇄되어야 한다.  
다시 말해 새로운 기능을 추가할 때 기존의 모듈, 클래스, 함수를 수정하기보다는 기존 코드를 기반으로 모듈, 클래스, 함수 등을 추가하는 방식으로 코드를 확장해야 한다는 뜻이다.

### 코드를 수정하는 것은 개방 폐쇄 원칙을 위반하는 것일까?

코드의 수정이 기존에 작성되었던 코드와 단위 테스트를 깨뜨리지 않는 한, 이는 개방 폐쇄 원칙을 위반하지 않는다고 판단해도 무방하다.  
새로운 기능을 추가할 때 소프트웨어 단위에 해당하는 모듈,클래스,메서드의 코드를 전혀 수정하지 않는 것은 불가능하다는 것을 인지해야 한다.  
따라서 우리는 수정을 아예 안하는 것이 아니라 수정을 가능한 한 상위 수준의 코드에서 진행하고,  
코드의 핵심 부분이나 복잡한 부분, 공통 코드나 기반 코드가 개방 폐쇄 원칙을 충족하는 방향으로 노력해야 한다.

### 개방 폐쇄 원칙을 달성하는 방법

개방 폐쇄 원칙은 코드의 확장성 문제라고도 볼 수 있는데, 이는 코드가 확장하기 쉬운지를 판단하는 표준에 해당한다.

- 확장 가능한 코드를 작성하려면 확장,추상화,캡슐화에 대해 인식하고 있는 것이 매우 중요하며, 이는 개발 기술 자체보다 훨씬 더 중요할 수 있다.
- 코드를 작성할 때 현재 코드에 앞으로 요구 사항이 추가될 가능성이 있는지 판단하는데 많은 시간을 할애할 필요가 있다.
- 코드의 변경 가능한 부분과 변경할 수 없는 부분을 잘 식별해야 한다.

## 3.3 리스코프 치환 원칙

`리스코프 치환 원칙 (Liskov Substitution Principle, LSP)`이란 부모 객체를 호출하는 동작에서 자식 객체가 부모 객체를 완전히 대체할 수 있다는 설계 원칙이다.

> 하위 유형 또는 파생 클래스의 객체는 프로그램 내에서 상위 클래스가 나타나는 모든 상황에서 대체 가능하며,  
> 프로그램이 원래 가지는 논리적인 동작이 변경되지 않고, 정확성도 유지된다.

### 리스코프 치환 원칙과 다형성의 차이점

- 다형성 : 코드를 구현하는 방식
- 리스코프 치환 원칙 : 상속 관계에서 하위 클래스의 설계 방식을 설명하는 설계 원칙

### 리스코프 치환 원칙을 위반하는 안티 패턴

리스코프 원칙에는 좀 더 이해하기 쉬운 설명 방식이 있다.  
바로 `계약에 따른 설계 (design by contract)`라는 표현이다.

다음은 리스코프 치환 원칙을 위반하는 코드의 예이다.

- **하위 클래스가 구현하려는 상위 클래스에서 선언한 기능을 위반하는 경우**
- **하위 클래스가 입력, 출력 및 예외에 대한 상위 클래스의 계약을 위반하는 경우**
- **하위 클래스가 상위 클래스의 주석에 나열된 특별 지침을 위반하는 경우**

하위 클래스의 설계와 구현이 리스코프 치환 원칙을 위반하는지 여부를 판단하기 위한 방법으로  
상위 클래스의 단위 테스트를 통해 하위 클래스의 코드를 확인하는 방법도 있다.

일부 단위 테스트가 실행되지 않으면 하위 클래스의 설계와 구현이 상위 클래스의 계약을 환전히 준수 하지 않고 하위 클래스가 리스코프 치환 원칙을 위반할 수 있음을 위미한다.

## 3.4 인터페이스 분리 원칙

`인터페이스 분리 원칙 (Interface Segregation Principle, ISP)`이란 클라이언트는 필요하지 않은 인터페이스를 사용하도록 강요되어서는 안된다는 설계 원칙이다.  
여기서 클라이언트는 인터페이스 호출자나 사용자로 이해하면 된다.

인터페이스 분리 원칙에서 이야기하는 인터페이스는 크게 다음 세가지 중 하나를 의미한다.
- API 또는 기능의 집합
- 단일 API 또는 기능
- 객체지향 프로그래밍의 인터페이스

### API 또는 기능의 집합으로서의 인터페이스

인터페이스 또는 기능의 일부가 호출자 중 일부에만 사용되거나 전혀 사용되지 않는다면 불필요한 항목을 강요하는 대신,  
인터페이스나 기능에서 해당 부분을 분리하여 해당 호출자에게 별도로 제공해야 한다.  
또한, 사용하지 않는 인터페이스나 기능에는 접근하지 못하게 해야한다.

### 단일 API 또는 기능으로서의 인터페이스

특정 메서드 안에서 여러 책임을 가지고 있다면 보다 세분화된 메서드 여러 개로 분할해야 한다.  
단일 책임 원칙과 다소 유사한데, 인터페이스 분리 원칙은 인터페이스에 단일 책임이 있는지 여부를 확인할 수 있는 방법을 제공한다.  
이는 호출자가 인터페이스의 일부 또는 그 기능의 일부만 사용하는 경우 해당 인터페이스 설계는 단일 책임 원칙을 충족하지 않는다고 말할 수 있다.

### 객체지향 프로그래밍에서의 인터페이스

포괄적인 인터페이스를 설계하기 보다는 분할된 여러개의 인터페이스로 설계하는 것이 확장성이 높고 재사용 하기 쉽다.  
또한 해당 인터페이스를 구현하는 입장에서 불필요한 코드를 구현할 확률을 줄일 수 있다.

## 3.5 의존 역전 원칙

`의존 역전 원칙 (Dependency Inversion Principle, DIP)`이란 다음과 같다.  
> 상위 모듈은 하위 모듈에 의존하지 않아야 하며, 추상화에 의존해야만 한다.  
> 또한, 추상화가 세부사항에 의존하는 것이 아니라, 세부 사항이 추상화에 의존해야 한다.

- 상위 모듈 : 호출자
- 하위 모듈 : 수신자

### 제어 반전?

`제어 반전 (Inversion of Control, IoC)`은 프로그램의 실행 흐름을 개발자가 아닌 프레임워크에 의해 제어되는 것을 의미한다.  
제어 반전은 특정한 기술이 아니라 일반적으로 프레임워크를 사용할 때 만나게 되는 보편적인 설계 사상에 가깝다.

### 의존성 주입?

`의존성 주입 (Dependency Injection, DI)`은 제어 반전과 달리 특정한 프로그래밍 기술이다.  
`new` 예약어를 사용하여 클래스 내부에 종속되는 클래스의 객체를 생성하는 대신, 외부에서 종속 클래스의 객체를 생성한 후 생성자, 함수의 매개변수 등을 통해 클래스에 주입하는 것을 의미한다.

## 3.6 KISS 원칙과 YAGNI 원칙

### KISS 원칙

`KISS 원칙 (Keep It Simple And Stupid)`이란 가능한 한 단순하게 유지하라는 설계 원칙이다.

KISS 원칙을 만족하는 코드를 작성하는 방법은 다음과 같다.

- 복잡한 정규표현식, 프로그래밍 언어에서 제공하는 지나치게 높은 레벨의 코드 등 지나치게 복잡한 기술을 사용하여 코드를 구현하지 않는다.
- 바퀴를 다시 발명하는 대신 기존 라이브러리를 사용하는 것을 고려한다.
- 과도하게 최적화하지 않는다.

### YAGNI 원칙

`YAGNI 원칙 (You aren's gonna need it)`은 과도하게 설계하지 말라는 설계 원칙이다.

### KISS 원칙과 YAGNI 원칙의 차이

`KISS 원칙 (Keep It Simple And Stupid)` : 가능한 한 간단하게 유지하라는 `방법`에 관한 것
`YAGNI 원칙 (You aren's gonna need it)` : 현재 필요하지 않은 것을 미리 하지 말라는 `금지`에 관한 것

## 3.7 DRY 원칙

`DRY 원칙 (Don't repeat yourself)`은 흔히 중복 코드를 작성하지 말라는 뜻으로 번역된다.  
하지만 중복에 의미에 대해 잘 알아야 한다.

- 코드 논리의 중복 : 코드 논리는 동일하지만 의미가 다르다면 중복이 아니다. DRY 원칙에 위배되지 않는다.  
  하지만 만약 이러한 코드 논리가 자주 나타난다면 보다 세분화된 기능을 추상화 하여 해결해야 한다.
- 기능적(의미론적) 중복 : 코드 논리는 중복되지 않지만 기능이 중복된다면 중복이다. DRY 원칙에 위배된다. 
- 코드 실행의 중복 : 코드 논리적 중복이나 의미적 중복이 없지만 코드 실행의 중복이 있다면 중복이다. DRY 원칙에 위배된다.

### 코드 재사용성

코드의 재사용성을 향상시키는 방법은 다음과 같다.

- 코드의 결합도를 줄인다.
- 단일 책임 원칙을 충족시켜야 한다.
- 코드의 모듈화는 필수다.
- 비즈니스 논리와 비즈니스 논리가 아닌 부분을 분리할 필요가 있다.
- 일반적인 코드는 하위 계층으로 내려보낸다.
- 상속, 다형성, 추상화, 캡슐화를 사용한다.
- 디자인 패턴을 활용하면 코드 재사용성을 향상시킬 수 있다.

위에 나열한 방법들을 따르는 것도 중요하지만 그 이상으로 의식적으로 코드 재사용을 하겠다는 마음을 가지는 것이 훨씬 더 중요하다.  
코드를 작성할 때마다 현재 작성중인 코드를 필요에 따라 독립적인 모듈, 클래스, 함수로 사용할 수 있는지 고려해야 한다.

## 3.8 LoD

`데메테르의 법칙 (Law Of Demeter, LoD)`이란 `최소 지식의 원칙(the least knowledge principle)`이라고도 한다.  

최소 지식의 원칙은 다음과 같다.
> 모든 유닛이 자신과 매우 밀접하게 관련된 유닛에 대해서 제한된 지식만 알아야 한다.  
> 또는 모든 유닛은 자신의 친구들에게만 이야기해야 하며, 알지 못하는 유닛과는 이야기하면 안된다.

LoD는 다음과 같이 정리할 수 있다.

- 직접 의존성이 없어야 하는 클래스 사이에는 반드시 의존성이 없어야 한다.
- 의존성이 있는 클래스는 필요한 인터페이스에만 의존해야 한다.

### 높은 응집도화 낮은 결합도

높은 응집도와 낮은 결합도는 코드의 가독성과 유지보수성을 효과적으로 향상시키고 기능 변경으로 인한 코드 변경 범위를 줄일 수 있는 매우 중요한 설계 사상이다.

높은 응집도 : 클래스 자체의 설계에 사용되며, 유사한 기능은 동일한 클래스에 배치되어야 하고, 유사하지 않은 기능은 다른 클래스로 분리해야 함을 의미한다.
낮은 결합도 : 클래스 간의 의존성 설계에 사용되며, 코드에서 클래스 간의 의존성이 단순하고 명확해야 함을 의미한다.

응집도와 결합도는 완전히 독립적이지 않기 때문에 높은 응집도는 낮은 결합도를 이끌어내며, 반대도 마찬가지이다.

응집도가 높고 결합도가 낮은 코드일수록 그 구조가 단순하고 명확하며, 그에 따라 코드의 가독성과 유지보수성이 높아진다.
