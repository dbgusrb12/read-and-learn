# 03. 설계 원칙

## 3.1 단일 책임 원칙

`단일 책임 원칙 (Sindle Responsibility Principle, SRP)`이란 클래스와 모듈은 하나의 책임 또는 기능만을 가지고 있어야 한다는 설계 원칙이다.

거대하고 포괄적인 클래스를 설계하는 대신, 작은 단위와 단일 기능을 가진 클래스를 설계해야 한다.  
다시 말해, 클래스에 비즈니스와 관련 없는 기능이 두 개 이상 포함되어 있으면 책임이 단일하지 않으므로, 단일 기능을 가진 여러 개의 작은 클래스로 분할되어야 한다.

### 클래스에 단일 책임이 있는지 판단하는 방법

클래스에 단일 책임이 있는지를 명가하기 위한 명확하고 정량화할 수 있는 표준은 존재하지 않는다.  
실제로 소프트웨어를 개발할 때는 과도하게 너무 세분화하여 설계할 필요는 없고,  
사업이 발전하면서 클래스에 기능이 추가되고, 코드가 복잡해지면서 거대해진 클래스를 여러 개의 세분화된 클래스로 나누면 된다.

단일 책임 여부를 결정하기 위해 사용되는 몇 가지 결정 원칙은 다음과 같다.
- 클래스에 코드, 함수 또는 속성이 너무 많아 코드의 가독성과 유지보수성에 영향을 미치는 경우 클래스 분할을 고려해야 한다.
- 클래스가 너무 과하게 다른 클래스에 의존한다면, 높은 응집도와 낮은 결합도의 코드 설계 사상에 부합하지 않으므로 클래스 분할을 고려해야 한다.
- 클래스에 `private` 메서드가 너무 많은 경우 `private` 메서드를 새로운 클래스로 분리하고  
  더 많은 클래스에서 사용할 수 있도록 `public` 메서드로 설정하여 코드의 재사용성을 향상시켜야한다.
- 클래스의 이름을 비즈니스적으로 정확하게 지정하기 어렵거나 `Manager`, `Context` 처럼 일반적인 단어가 아니면 클래스의 이름을 정의하기 어려울 경우,  
  클래스의 책임 정의가 충분히 명확하지 않음을 의미할 수 있다.
- 클래스의 많은 메서드가 여러 속성 중 일부에서만 작동하는 경우 이러한 속성과 해당 메서드를 분할하는 것을 고려할 수 있다.

### 클래스의 책임이 가능한 한 자세하게 설명되어 있는지 여부

클래스를 최대한 작게 나누는것만이 꼭 정답은 아니다.  
책임을 나눔으로써 코드의 응집력이 낮아지게 되면 코드의 유지보수성이 낮아지는 결과를 초래할 수 있다.

설계 원칙을 적용하든 디자인 패턴을 적용하든 그 목표는 코드의 가독성, 확장성, 재사용성, 유지보수성을 향상시키는 것이다.  
어떤 설계 원칙을 적용하는 것이 타당한지를 판단할 때 이 목표를 최종 평가 기준으로 삼아야한다.

## 3.2 개방 폐쇄 원칙

`개방 폐쇄 원칙 (Open-Closed Principle, OCP)`이란 확장에는 열려있고, 수정에는 닫혀있어야 한다는 설계 원칙이다.

SOLID 원칙 중 가장 이해하기 어렵고, 마스터하기 어려우며 가장 유용한 원칙이기도하다.  
그 이유는 코드를 변경할 때 그 결과를 `확장`으로 보아야 하는지, `수정`으로 보아야 하는지 명확하게 구분하기 어렵지 때문이다.

### 확장할 때는 개방, 수정할 때는 폐쇄

모듈, 클래스, 함수와 같은 소프트웨어의 단위들은 확장을 위해 개방되어야 하지만 수정을 위해서는 폐쇄되어야 한다.  
다시 말해 새로운 기능을 추가할 때 기존의 모듈, 클래스, 함수를 수정하기보다는 기존 코드를 기반으로 모듈, 클래스, 함수 등을 추가하는 방식으로 코드를 확장해야 한다는 뜻이다.

### 코드를 수정하는 것은 개방 폐쇄 원칙을 위반하는 것일까?

코드의 수정이 기존에 작성되었던 코드와 단위 테스트를 깨뜨리지 않는 한, 이는 개방 폐쇄 원칙을 위반하지 않는다고 판단해도 무방하다.  
새로운 기능을 추가할 때 소프트웨어 단위에 해당하는 모듈,클래스,메서드의 코드를 전혀 수정하지 않는 것은 불가능하다는 것을 인지해야 한다.  
따라서 우리는 수정을 아예 안하는 것이 아니라 수정을 가능한 한 상위 수준의 코드에서 진행하고,  
코드의 핵심 부분이나 복잡한 부분, 공통 코드나 기반 코드가 개방 폐쇄 원칙을 충족하는 방향으로 노력해야 한다.

### 개방 폐쇄 원칙을 달성하는 방법

개방 폐쇄 원칙은 코드의 확장성 문제라고도 볼 수 있는데, 이는 코드가 확장하기 쉬운지를 판단하는 표준에 해당한다.

- 확장 가능한 코드를 작성하려면 확장,추상화,캡슐화에 대해 인식하고 있는 것이 매우 중요하며, 이는 개발 기술 자체보다 훨씬 더 중요할 수 있다.
- 코드를 작성할 때 현재 코드에 앞으로 요구 사항이 추가될 가능성이 있는지 판단하는데 많은 시간을 할애할 필요가 있다.
- 코드의 변경 가능한 부분과 변경할 수 없는 부분을 잘 식별해야 한다.

## 3.3 리스코프 치환 원칙

`리스코프 치환 원칙 (Liskov Substitution Principle, LSP)`이란 부모 객체를 호출하는 동작에서 자식 객체가 부모 객체를 완전히 대체할 수 있다는 설계 원칙이다.

> 하위 유형 또는 파생 클래스의 객체는 프로그램 내에서 상위 클래스가 나타나는 모든 상황에서 대체 가능하며,  
> 프로그램이 원래 가지는 논리적인 동작이 변경되지 않고, 정확성도 유지된다.

### 리스코프 치환 원칙과 다형성의 차이점

- 다형성 : 코드를 구현하는 방식
- 리스코프 치환 원칙 : 상속 관계에서 하위 클래스의 설계 방식을 설명하는 설계 원칙

### 리스코프 치환 원칙을 위반하는 안티 패턴

리스코프 원칙에는 좀 더 이해하기 쉬운 설명 방식이 있다.  
바로 `계약에 따른 설계 (design by contract)`라는 표현이다.

다음은 리스코프 치환 원칙을 위반하는 코드의 예이다.

- **하위 클래스가 구현하려는 상위 클래스에서 선언한 기능을 위반하는 경우**
- **하위 클래스가 입력, 출력 및 예외에 대한 상위 클래스의 계약을 위반하는 경우**
- **하위 클래스가 상위 클래스의 주석에 나열된 특별 지침을 위반하는 경우**

하위 클래스의 설계와 구현이 리스코프 치환 원칙을 위반하는지 여부를 판단하기 위한 방법으로  
상위 클래스의 단위 테스트를 통해 하위 클래스의 코드를 확인하는 방법도 있다.

일부 단위 테스트가 실행되지 않으면 하위 클래스의 설계와 구현이 상위 클래스의 계약을 환전히 준수 하지 않고 하위 클래스가 리스코프 치환 원칙을 위반할 수 있음을 위미한다.
