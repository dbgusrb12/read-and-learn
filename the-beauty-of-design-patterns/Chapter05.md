# 05. 리팩터링 기법

## 5.1 리팩터링의 네 가지 요소: 목적, 대상, 시기, 방법

### 리팩터링의 목적

> 리팩터링은 코드에 대한 이해를 쉽게 하기 위해 소프트웨어의 내부 구조를 개선하는 것으로,  
> 소프트웨어의 외부 동작을 변경하지 않고 수정 비용을 줄이는 것을 목적으로 한다.

- 리팩터링은 코드 품질을 보장하는 효과적인 수단이며 코드 품질 저하를 효과적으로 방지할 수 있다.
- 고품질 코드는 훌륭한 설계 한 번에 나오는 것이 아니라 반복적인 작업의 결과로 나오는 것이다.
- 리팩터링은 일시적으로 불완전한 설계를 덮을 수 있는 과도한 설계를 피하는 효과적인 방법이다.

### 리팩터링의 대상

규모에 따라 대상이 다르다.
- 대규모(고수준) 리팩터링 : 시스템, 모듈, 코드 구조, 클래스 간 관계의 리팩터링을 포함해 최상위 코드 설계를 리팩터링 하는 것
- 소규모(저수준) 리팩터링 : 클래스, 함수, 변수 수준에서 코드 세부 정보를 리팩터링 하는 것

### 리팩터링의 시기

**코드가 이미 망가진 후에 모든 문제를 한꺼번에 해결하는 수단으로 리팩터링에 의존하면 안된다.**

지속적인 리팩터링을 통한 지속 가능하고 진화적인 리팩터링 계획을 탐구해야한다.  
단위 테스트와 코드 리뷰를 개발의 일부로 취급하는 것처럼 지속적인 리팩터링을 개발의 일부로 다루어야 한다.

지속적인 리팩터링이 개발 습관이 되고 팀 내에서 합의가 이루어진다면 코드 품질은 보장된다.

### 리팩터링의 방법

규모에 따라 방법이 다르다.
- 대규모(고수준) 리팩터링 : 사전에 종합적인 리팩터링 계획을 수립해, 질서 있고 단계적으로 진행. 코드 저장소의 코드가 항상 실행 가능한 상태가 되도록 해야 한다.
- 소규모(저수준) 리팩터링 : 표준 명명, 표준 주석, 초대형 클래스와 함수 제거, 중복 코드 추출과 같이 영향을 미치는 범위가 작고 변경 사항이 적기 때문에 원한다면 시간이 있을 때마다 가능하다. 코드 분석 도구를 사용하는 것도 좋다.

## 5.2 단위 테스트

잘못된 리팩터링을 방지하기 위해서는?
- 고전적인 설계 원칙과 디자인 패턴에 능숙해야 할 뿐만 아니라 비즈니스와 코드에 대한 충분한 이해가 필요하다.  
- 단위 테스트를 통해 리팩터링이 잘 됐는지 확인을 한다.

### 단위 테스트에 대해

코드의 정확성을 테스트하기 위한 것이지만, 테스트 엔지니어가 아닌 개발 엔지니어가 작성하는 것이다.
- 범위: 코드 수준의 테스트
- 대상: 클래스 또는 함수로 제한

### 단위 테스트 코드를 작성하는 이유

- 프로그래머가 코드에서 버그를 찾는 데 도움이 될 수 있다.
- 프로그래머가 코드 설계에서 문제를 찾는 데 도움이 될 수 있다.
- 통합 테스트를 보완하는 강력한 도구이다.
- 단위 테스트 코드를 작성하는 과정은 코드 리팩터링 과정에 해당된다.
- 프로그래머가 코드에 빠르게 익숙해지도록 도와준다.
- 테스트 주도 개발을 개선하고 대체할 수 있다.

### 단위 테스트를 설계하는 방법

단위 테스트는 코드에 대한 다양한 입력, 예외, 경계 조건을 다루는 테스트 케이스를 설계하고 테스트 케이스를 코드로 변환하는 프로세스이다.

- 단위 테스트를 설계하는 것은 시간이 많이 걸리는 일인가? => **구현이 간단하고 설계를 고려할 필요가 없기 때문에 작성에 많은 시간이 필요하지 않다.**
- 단위 테스트 코드의 품질에 대한 요구 사항이 있는가? => **단위 테스트 코드는 프로덕션 환경에서 실행되지 않고, 독립적이며 의존하지 않으므로 품질에 대한 요구 사항을 적절한 수준으로 낮출 수 있다.**
- 단위 테스트의 커버리지가 높으면 그것만으로 충분한가? => **커버리지를 단위 테스트 품질의 유일한 척도로 사용하는 것은 비합리적이다. 테스트 케이스가 모든 가능한 케이스, 특히 일부 특별한 케이스를 포함하는지 여부에 더 주의를 기울여야 한다.**
- 단위 테스트 코드를 작성할 때 코드의 구현 논리를 이해해야 할까? => **특정 구현 논리에 의존하지 않으며, 기능에만 초점을 맞춘다**
- 단위 테스트 프레임워크를 선택하는 방법은? => **복잡한 기술이 필요치 않으므로 회사나 팀 내에서 동일한 프레임워크를 사용하기만 한다면 아무거나 사용해도 된다.**

### 단위 테스트를 작성하기 어려운 이유

- 번거롭고, 특별한 기술을 습득할 수 있는게 아니기 때문에 꺼리는 경우가 많음
- 개발 작업이 길어지고 많아질수록 `깨진 유리창 효과`가 발생해 단위 테스트 코드 작성을 하지 않게 됨
- 이미 코드가 너무 많이 쌓여있기 때문에

하지만 잘 작성된 단위 테스트와 코드 리뷰를 통해 코드의 품질에 신경 쓰면 테스트 시간을 크게 줄일 수 있다.  
단위 테스트의 이점을 진정으로 느낄 때만 이를 인식하고 사용할 수 있다.

## 5.3 코드 테스트 용이성

### 테스트 가능한 코드를 작성하는 방법

클래스의 단위 테스트 코드가 작성하기 쉬운가에 대한 부분은  
클래스의 독립성, 즉 해당 클래스가 높은 응집도와 낮은 결합도를 만족하는지에 따라 결정된다.

**코드가 제어할 수 없는 구성 요소에 종속되는 경우 이 종속 관계를 끊을 방법이 필요하다.**  
=> 의존성 주입과 모의 구현(Mock)을 통해 구현

### 테스트가 불가능한 코드

- 보류 중인 동작 : 코드의 출력이 무작위이거나 불확실하며 시간 및 난수와 관련이 있는 코드. 매번 다른값이 반환되는 불확실한 실행 결과가 나오게 되면 정확성을 테스트 할 수 없다.
- 전역 변수 : 초기화 된 정적 변수가 변경되는 코드. 여러개의 단위테스트를 순차적으로 실행하거나 멀티 스레드로 동시에 실행하게 될 때 테스트의 일관성을 해칠 수 있다.
- 정적 메서드 : 정적 메서드는 모의 구현이 어렵기 때문에 코드 테스트 용이성이 떨어지는 경우가 간혹 있을 수 있다.
- 복잡한 상속 관계 : 합성 관계에 비해 결합성이 높은 상속 관계의 경우, 상위 클래스의 종속 객체를 모의 구현해야 하는 경우, 상속받는 모든 하위 클래스의 테스트에서 전부 모의 구현해야 한다.

## 5.4 디커플링

### 디커플링이 중요한 이유

복잡한 코드는 가독성과 유지보수성에 문제가 있는 경우가 많다.  
코드의 복잡성을 제어할 수 있는 방법 중 가장 효과적인 방법은 바로 디커플링이다.

디커플링을 통해 응집도가 높고 결합도가 낮은 코드를 만들 수 있으며, 이와 같은 방식으로 코드를 리팩터링하면 코드의 복잡성을 효과적으로 제어할 수 있게 된다.

### 코드를 디커플링해야 하는지 판단하기

- 기능 코드의 일부가 수정되면 전체 코드를 모두 건드려야 하는 상황이 발생할 때
- 모듈과 클래스 간의 의존성을 따져본 후, 의존성 그래프의 복잡성이 높을 때

### 코드 디커플링 방법

#### 캡슐화와 추상화로 디커플링

구현의 복잡성을 숨기고 구현의 변동성을 격리하며 상위 모듈에게 안정적이고 사용하기 쉬운 인터페이스를 제공할 수 있다.

#### 중간 계층으로 디커플링

중간 계층은 모듈 사이 또는 클래스 사이의 의존성을 단순화 할 수 있다.

리팩터링을 진행할 때도 중간 계층이 과도기적 역할을 할 수 있기 때문에 개발 프로세스와 리팩터링 프로세스가 서로 간섭하지 않고 동시에 진행 될 수 있다.  
아래 4단계의 과정을 거쳐 수정하면 리팩터링을 작고 빠르게 실행할 수 있다.
1. 중간 계층을 도입하고 이를 사용하여 이전 인터페이스를 감싸는 새 인터페이스를 제공한다.
2. 새로 개발된 코드는 중간 계층에서 제공하는 새로운 인터페이스에만 의존한다.
3. 이전 인터페이스에 종속된 코드를 전부 변경하여 새 인터페이스를 호출한다.
4. 모든 코드가 새 인터페이스를 호출하는지 확인한 후 이전 인터페이스를 제거한다.

#### 모듈화와 계층화로 디커플링

- 모듈화: 각 모듈을 독립적인 클래스 라이브러리로 개발하고, 각각의 모듈은 다른 모듈이 클래스의 내부에 접근할 수 있도록 구현 세부 사항을 캡슐화해서 인터페이스 형태로 제공한다면 모듈 사이의 결합도를 낮출 수 있다.  
- 계층화: 각 계층은 구현 세부 사항을 캡슐화하고 상위 계층에서 사용할 추상 인터페이스를 노출한다. 재사용이 용이하고 특정 비즈니스와 관계없는 코드는 최대한 하위 계층, 수정이 빈번한 특정 비즈니스와 깊게 관련된 코드는 상위 계층으로 위치해야 한다.

#### 고전적인 코드 설계 원칙과 사상을 사용한 디커플링

- 단일 책임 원칙 : 모듈/클래스에 단일 책임이 있는 경우 클래스 간의 의존도는 줄어들고 코드의 결합도도 낮아진다.
- 구현이 아닌 인터페이스 기반의 프로그래밍 : 의존성이 있는 서로 다른 모듈/클래스 사이에서 특정 모듈/클래스의 변경 사항이 다른 모듈/클래스에 영향을 미치지 않는다.
- 의존성 주입 : 모듈/클래스 사이의 강한 결합을 약한 결합으로 바꿀 수 있다.
- 상속보다는 합성을 더 많이 사용 : 상위 클래스의 변경 사항은 모든 하위 클래스에 영향을 미치기 때문에 합성의 약한 의존 관계로 대체하면 디커플링이 가능해진다.
- LoD를 따르는 것 : 직접 의존성이 없어야 하는 클래스 사이에는 반드시 의존성이 없어야 하며, 의존성이 있는 클래스는 필요한 인터페이스에만 의존한다면 코드의 결합도를 낮게 유지할 수 있다.
