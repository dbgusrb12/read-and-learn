# 서버의 개요

## 클라이언트와 서버의 차이점

클라이언트와 서버는 네트워크에 관한 부분은 같지만, 용도에 따라 다양한 서버 머신의 종류가 있으며, 하드웨어나 OS 부분은 다르다.

네트워크에 관한 부분, LAN 어댑터, 프로토콜 스택, Socket 라이브러리 등의 기능이 같아도 사용하는 방법까지 같은 것은 아닌데,  
접속 동작을 할 때 클라이언트에서는 접속 동작을 수행하고, 서버는 그걸 기다리는 형태가 되므로 Socket 라이브러리의 사용법이 조금 달라진다.  
그래서 애플리케이션이 호출하는 Socket 라이브러리의 프로그램 부품이 다른 것이다.

또한 서버의 애플리케이션은 동시에 다수의 클라이언트 PC와 대화한다는 차이점이 있기 때문에 서버 애플리케이션은 클라이언트 애플리케이션과 구조가 다르다.

## 서버 애플리케이션의 구조

서버는 복수의 클라이언트와 동시에 통신 동작을 실행하지만, 하나의 프로그램으로 여러 클라이언트들의 상대를 처리하기는 어렵다.  
때문에 클라이언트가 접속할 때마다 새로 서버 프로그램을 작동하여 서버 애플리케이션과 클라이언트가 1:1로 대화하는 방법을 선택하는 것이 일반적이다.

먼저 서버 프로그램의 접속을 기다리는 부분과 클라이언트와 대화하는 부분, 둘로 나누어 서버 프로그램을 만든다.  
그 후 서버 프로그램을 작동해서 설정 파일 읽기 등의 초기화 동작을 마쳤을 때 접속을 기다리는 부분을 실행한다.  
그러면 해당 부분이 소켓을 작성하고 소켓을 클라이언트에서의 접속 동작을 기다리는 상태로 만든 채 쉬는 상태가 되는데,  
그 이후 클라이언트가 접속했을 때 다시 작동하여 접속을 기다리고, 클라이언트와 대화하는 부분을 작동시켜 해당 부분에 접속이 끝난 소켓을 건네주고  
동작을 계속하면 클라이언트와 대화하는 부분은 접속이 끝난 소켓을 사용하여 클라이언트와 대화하기 시작한다. 대화가 끝나면 연결을 끊고 이 부분이 종료된다.

클라이언트가 대화하는 부분은 새 클라이언트가 접속할 때마다 생성되어 기동하므로 한 대의 클라이언트와 1:1로 대응을 한다. 이렇게 하면  
다른 클라이언트의 일에 신경쓰지 않고 자신에 대응하는 클라이언트만 상대하면 되기 때문이다.  

서버 OS는 멀티태스크 또는 멀티스레드라는 기능에 의해 다수의 프로그램을 동시에 함께 작동 할 수 있는데, 이 성질을 이용한 프로그래밍 기법이다.

이러한 방법은 클라이언트가 접속했을 때 새로 프로그램을 기동하는 부분에서 다소 시간이 걸리고, 응답 시간이 추가로 소요된다는 단점이 있기 때문에,  
미리 클라이언트와 대화하는 몇 개의 부분을 작동시켜 두고 클라이언트가 접속했을 때 클라이언트의 상대를 처리하지 않는 비어있는 것을 찾아 접속한 소켓을  
건네주어 클라이언트와 대화를 계속하는 방법도 있다.

## 서버측의 소켓과 포트 번호

클라이언트의 데이터 송/수신 동작의 단계는 다음과 같다.

- 소켓을 만든다. (소켓 작성 단계)
- 서버측의 소켓과 파이프로 연결한다. (접속 단계)
- 데이터를 송/수신 한다. (송/수신 단계)
- 파이프를 분리하고 소켓을 말소한다. (연결 끊기 단계)

서버측의 데이터 송/수신 동작의 단계는 다음과 같다.

- 소켓을 만든다. (소켓 작성 단계)
- 소켓을 접속 대기 상태로 만든다. (접속 대기 상태)
- 접속을 접수한다. (접속 접수 단계)
- 데이터를 송/수신 한다. (송/수신 단계)
- 파이프를 분리하고 소케을 말소한다. (연결 끊기 단계)

서버측에서 socket 라이브러리를 사용하는 구체적인 동작은 다음과 같다.

먼저 socket 을 호출하여 소켓을 만들고, bind 를 호출하여 소켓에 포트 번호를 기록한다.  
그 후 listen 을 호출하여 소켓에 접속하기를 기다리는 상태라는 제어 정보를 기록하여 클라이언트에서 접속 동작의 패킷이 도착하는 것을  
기다리는 상태가 되고, accept 를 호출하여 접속을 접수한다.
이 상태에서 접속 패킷이 도착하면 응답 패킷을 반송하여 접속 접수 동작을 실행한다. 그리고 접속 대기의 소켓을 복사해 새로운 소켓을 만들고,  
접속 상대의 정보를 비롯한 제어 정보를 새 소켓에 기록한다. 그 이후의 과정은 데이터 송/수신 동작이므로 클라이언트와 마찬가지이다.

여기서 접속 동작을 할 때 만든 새 소켓이 아니라 원래 있던 접속 대기 상태의 소켓은 계속 접속 대기 상태인 채로 존재한다.  
그리고 다시 accept 를 호출하면 클라이언트에서의 접속 패킷이 도착했을 때 접속 접수 동작을 실행한다.  
이 때 접속 대기의 소켓을 복사하여 새 소켓을 만들고, 새 소켓을 클라이언트측의 소켓과 접속한 후 원래 소켓은 그대로 접속 대기 상태인 채로 둔다.  
이렇게 잇달아 복사해 새 소켓을 만드는 부분이 요점이다. 새 소켓을 만들지 않고 접속 대기의 소켓에 그대로 접속하면 접속 대기의 소켓이 없어져  
버리므로 다음에 다른 클라이언트가 접속하면 곤란해지기 때문에 이러한 사태를 막기 위해 새 소켓을 만들고 여기에 접속하는 것이다.

포트 번호는 소켓을 식별하기 위해 사용하는 것이므로 소켓마다 다른 값을 할당해야 한다는 개념을 고수하려면 곤란하다. 이 개념을 고수하려면 접속 대기  
동작을 할 때 새로 만드는 소켓에는 원래의 접속 대기 소켓과는 다른 포트 번호를 할당해야 한다.  
예를 들어 클라이언트에서 80번이라는 포트 번호의 소켓에 접속 패킷을 보냈을 때 이것과는 다른 포트 번호의 소켓에서 회답이 돌아온다.  
이렇게 되면 접속 패킷을 보낸 상대로부터 회답이 돌아왔는지, 아니면 다른 상대로부터 잘못된 회답의 패킷이 돌아왔는지 판별할 수 없다.  
그러므로 새로 만든 소켓에도 접속 대기 소켓과 같은 포트 번호를 할당해야 한다.

이렇게하면 포트 번호는 소켓을 지정하기 위한 것인데, 같은 번호를 할당한 여러 개의 소켓이 존재해서 포트 번호로 소켓을 지정 할 수 없게 된다는  
문제가 있는데, 이 문제는 소켓을 지정할 때 서버측의 소켓에 할당한 포트 번호 뿐만 아니라 클라이언트측의 포트 번호, IP 주소도 추가하여  
4가지 정보를 사용하는 방법으로 해결 할 수 있다.