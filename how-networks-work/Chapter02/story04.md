# 서버에서 연결을 끊어 소켓을 말소한다.

## 데이터 보내기를 완료했을 때 연결을 끊는다.

데이터 송/수신을 종료하는 것은 애플리케이션이 송신해야 하는 데이터를 전부 송신 완료했다고 판단했을 때이다.

그 때 송신을 완료한 측이 연결 끊기 단계로 들어가는데,  
어디에서 데이터 송/수신 동작이 끝나는지는 애플리케이션에 따라 다르다.

웹에서는 서버에서 연결 끊기 단계로 들어가는 상황이 많기 때문에, 서버측을 기준으로 설명하면,  
서버측의 애플리케이션이 Socket 라이브러리의 `close` 를 호출한다.  
그러면 서버측 프로토콜 스택이 TCP 헤더를 만들고, 여기에 연결 끊기를 나타내는 정보를 설정한다.

구체적으로는 컨트롤 비트의 FIN 비트에 1을 설정하고, IP 담당 부분에 의뢰하여 클라이언트에 송신해 달라고  
요청하고, 서버측 소켓에 연결 끊기 동작에 들어갔다는 정보를 기록한다.

클라이언트 측에서는 서버에서 FIN 이 1인 TCP 헤더가 도착하면 자신의 소켓에 서버측이 연결 끊기 동작에  
들어갔다는 것을 기록한 뒤, FIN 을 1로 받았다는 사실을 알리기 위해 ACK 번호로 서버측에 반송한다.  

잠시 후 애플리케이션이 `read` 를 호출하여 데이터를 가지러 올 때, 데이터를 바로 건네지 않고 서버에서  
보낸 데이터를 전부 수신 완료했다는 사실을 클라이언트측 애플리케이션에 알린다.

웹은 서버가 응답을 반송하면 끝나도록 규칙으로 정해져있기 때문에 서버에서 보낸 데이터를 전부 수신 완료하면  
클라이언트도 종료한다.  
그래서 클라이언트측 애플리케이션도 `close`를 호출하여 데이터 송/수신 동작을 끝낸다.

그 때 클라이언트측의 프로토콜 스택은 서버측과 마찬가지로 FIN 비트에 1을 설정한 TCP 헤더를 만들고 IP 담당  
부분에 의뢰하여 서버에 송신 한 후 서버에서 ACK 번호가 돌아오면 종료된다.

## 소켓을 말소한다.

서버와 대화가 끝나면 소켓을 사용하여 서버와 대화할 수 없게 되기 때문에 소켓은 필요 없지만,  
오동작을 막기 위해 바로 소켓을 말소 하지 않고 잠시 기다린 후 소켓을 말소한다.

간단한 예시로 클라이언트에서 먼저 연결 끊기 동작이 시작됐다고 가정해보면,  

1. 클라이언트가 FIN 송신
2. 서버가 ACK 번호 송신
3. 서버가 FIN 송신
4. 클라이언트가 ACK 번호 송신

이런 경우로 가게 되는데, 이 경우 서버는 ACK 번호가 돌아오지 않으므로 다시 한 번 FIN 을 보낼 수도 있다.  
이 때 클라이언트의 소켓이 말소되어 있으면 해당 소켓에 기록되어있던 제어 정보가 없어지므로,  
소켓에 할당되어 있던 포트 번호도 몇 번인지 알 수 없게 되고, 이 시점에 다른 애플리케이션이 새 소켓을  
작성하여 같은 포트 번호가 할당 된다면 서버가 다시 보낸 FIN 이 새로 할당된 소켓에 보내 질 수도 있다.  
그렇게 된다면, 해당 소켓은 작성되자마자 연결 끊기 동작에 들어 갈 수도 있다.

이런 오작동을 막기 위해 소켓을 바로 말소하지 않고, 잠시 기다렸다가 말소하는 것이다.  
이 때 기다리는 시간은 패킷을 다시 보내는 동작과 관계가 있는데, 패킷이 없어졌을 때 다시 보내는 동작을 하는 것처럼,  
다시 보내기 동작이 완전히 끝나는 시간만 기다린 뒤 말소한다.

## 데이터 송/수신 동작을 정리한다.

TCP 프로토콜에서 애플리케이션의 데이터를 송/수신하는 동작을 정리해 보자면,  

### 데이터 송/수신에 필요한 소켓을 작성한다.

보통 서버측에서 애플리케이션이 동작하기 시작했을 때 소켓을 만들고 해당 소켓을 접속 대기 상태로  
만든다.  
클라이언트측은 사용자가 무언가 조치를 취하여 서버에 액세스하는 동작이 시작될 때 일반적으로 패킷을 작성하지만,  
이 단계에서는 아직 패킷을 주고받지 않는다.

### 클라이언트에서 서버를 향해 접속 동작을 실행한다.

먼저 클라이언트가 `SYN` 을 1로 만든 TCP 헤더를 만들어 서버에 보내는데,  
이 TCP 헤더에는 시퀀스 번호의 초기값 (클라이언트가 서버에 데이터를 보낼 때 사용) 과  
윈도우의 값(서버에서 클라이언트에 데이터를 송신 할 때 사용)도 기록이 되어 있다.

해당 TCP 헤더가 서버에 도착하면 서버에서도 TCP 헤더를 반송하는데, 해당 헤더에는 `SYN` 을 1로 만든 값과  
시퀀스 번호, 윈도우 값 이 기록되어 있고, 그 외에 TCP 헤더를 받은 것을 나타내는 `ACK` 번호도 기록되어 있다.  

반송된 헤더가 클라이언트에 도착하면, 클라이언트에서도 마찬가지로 TCP 헤더를 받았다는 의미에서 `ACK` 번호를  
기록한 TCP 헤더를 다시 서버에 보낸다.

이 단계가 끝나면 접속 동작이 끝나고, 데이터 송/수신 단계로 들어간다.

### 리퀘스트 메시지를 보낸다.

TCP 는 해당 리퀘스트 메시지를 적당한 크기의 조각으로 분할하고, 송신 데이터가 몇 번째 바이트부터  
시작하는지 나타내는 시퀀스 번호를 TCP 헤더에 기록하고, 해당 TCP 헤더를 맨 앞에 부가하여 서버에 보낸다.  
이것이 서버에 도착하면 서버는 `ACK` 번호를 클라이언트에 반송한다.  
클라이언트에서 보내는 최초의 데이터 조각인 경우 서버는 데이터를 받기만 하지만,  
데이터의 송/수신이 진행되면 애플리케이션에 데이터를 건네주는 일이 생기고, 수신 버퍼에도 빈 영역이 생기는  
순간이 있는데, 그 때 윈도우의 값도 기록하여 클라이언트에 같이 통지를 한다.  

### 서버가 응답 메시지를 반송한다.

클라이언트에서 서버로 보내는 방식인 리퀘스트 메시지를 보내는 것과 반대로 진행이 된다.

### 연결 끊기 동작에 들어간다.

서버에서 먼저 연결 끊기 동작에 들어가고, `FIN` 을 1로 만든 TCP 헤더를 클라이언트에 보낸다.  
그러면 클라이언트에서 해당 TCP 헤더를 받았다는 의미로 `ACK` 번호를 서버에 반송한 뒤,  
애플리케이션이 데이터를 가지러 올 때까지 기다린 뒤, 데이터를 가지러 오면 서버측 데이터가 전부 수신되었다고  
알려준다.  
클라이언트측 애플리케이션에서 연결 끊기 동작에 들어가고, 반대로 클라이언트측에서 `FIN` 을 1로 만든  
TCP 헤더를 서버에 보내고, 서버에서는 받았다는 의미로 `ACK` 번호를 반송한 후 소켓이 말소된다.