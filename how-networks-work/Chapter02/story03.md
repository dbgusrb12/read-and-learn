# 데이터를 송/수신한다.

## 프로토콜 스택에 HTTP 리퀘스트 메시지를 넘긴다.

`connect`에서 애플리케이션에 제어가 되돌아오면 데이터 송/수신 동작에 들어간다.

프로토콜 스택에서는 받은 데이터를 곧바로 송신 하지 않고,  
자체 내부에 있는 송신용 버퍼 메모리 영역에 저장한 뒤 애플리케이션이 다음 데이터를 건네주기를 기다린다.  
이렇게 하는 이유는 프로토콜 스택에 건네주는 데이터의 길이가 애플리케이션의 종류나 만드는 방법에 따라 다르기 때문이다.

데이터를 한꺼번에 전부 송신 의뢰하는 경우도 있고, 1바이트나 1행씩 세분하여 송신 의뢰하는 경우도 있는데,  
프로토콜 스택에서 결정하거나 제어 할 수 없기 때문에 받은 데이터를 곧바로 보내면 작은 패킷을 여러번 보내야  
하는 상황이 생기고, 네트워크 이용 효율이 저하되는 문제가 있기 때문에 어느 정도 데이터를 저장하고 나서  
송/수신 동작을 실행한다.

어느 정도까지 데이터를 저장한 후 송신할지에 대한 판단 요소는 OS의 종류나 버전에 따라 다르지만,  
다음과 같은 요소를 바탕으로 판단한다.

### 한 패킷의 저장할 수 있는 데이터의 크기

프로토콜 스택은 `MTU`라는 매개변수를 바탕으로 판단한다.

`MTU`는 한 패킷으로 운반할 수 있는 디지털 데이터의 최대 길이로, 이더넷 기준으로는 보통  
1500바이트이다.

`MTU` 에는 패킷의 맨 앞부분에 헤더가 포함되어 있기 때문에, 헤더를 제외한 것이 하나의 패킷으로 운반할 수 있는  
데이터의 최대 길이가 되고, 이걸 `MSS` 라고 한다.

애플리케이션에서 받은 데이터가 `MSS`를 초과하거나 `MSS`에 가까운 길이에 이르기까지  
데이터를 저장하고 송신 동작을 하면 패킷이 잘게 나누어질 걱정을 할 필요가 없다.

### 타이밍

애플리케이션의 송신 속도가 느려지는 경우 `MSS` 에 가깝게 데이터를 저장하면 여기에서 시간이 걸려  
송신 동작이 지연되기 때문에 버퍼에 데이터가 모이지 않아도 적당한 곳에서 송신동작을 실행해야 되는데,  
이 기준은 프로토콜 스택 내부에 타이머이다.

이 타이머가 돌고, 일정 시간 이상 경과하면 패킷을 송신한다.

이 두가지 사항은 프로토콜 스택 내부의 동작들이고, 개발자가 원한다면 애플리케이션측에서  
송신 타이밍을 제어 할 수도 있다.

데이터 송신을 의뢰할 때 옵션을 지정 할 수 있으면, 버퍼에 머물지 않고 바로 송신 할 수도 있다.

## 데이터가 클 때는 분할하여 보낸다.

애플리케이션에서 보내준 데이터가 `MSS`의 길이를 초과할 경우, 프로토콜 스택에서는  
`MSS`의 길이에 맞게 데이터를 분할하여 한 개씩 패킷에 넣어 송신한다.

## ACK 번호를 사용하여 패킷이 도착했는지 확인한다.

송신쪽 TCP 담당 부분은 데이터를 분할 할 때 통신 개시부터 몇번째 바이트에 해당하는지 세어둔 뒤,  
분할 된 데이터를 송신할 때 세어둔 값을 TCP 헤더의 시퀀스 번호라는 필드에 담는다.

수신측에서는 패킷 전체 길이에서 헤더 길이를 빼면 데이터의 크기를 계산할 수 있기 때문에  
데이터의 크기는 헤더에 담지 않는다.

수신측에서는 송신측에서 보낸 헤더에 시퀀스 번호를 읽고, 데이터의 크기를 계산한 뒤  
패킷이 누락되었는지 확인하고, 누락이 없는 것을 확인하면 몇번째 바이트까지 수신받았는지를  
ACK 번호에 기록하여 송신측에 전달한다.

이 ACK 번호를 되돌려주는 동작을 `수신 확인 응답` 이라고 부르며, 송신측은 이것을 통해  
상대가 어디까지 수신했는지 파악한다.

시퀀스 번호는 1부터 시작하지 않고, 난수를 바탕으로 산출한 초기값으로 시작을 한다.  
그 이유는 1부터 시작한다면 악의적인 공격을 대비하기 어렵기 때문이다.  
하지만 시퀀스 번호가 항상 변하면 수신측에서 대응 할 수 없기 떄문에 송/수신을 시작하기 전에  
(`SYN` 을 1로 설정할 때) 초기값을 미리 상대에서 알리게 되어있다.

이렇게 시퀀스 번호와 ACK 번호를 사용하여 확인 하는 방법이 있는데,  
양방향 통신일 경우도 마찬가지다.

먼저 클라이언트에서 시퀀스 번호 초기값을 서버에 통지하고, 서버는 초기값 받은 것을 반송해  
초기값을 세팅한다.  
그 후 클라이언트에서 산출한 시퀀스 번호와 데이터를 보내고, 서버에서는 ACK 번호를 산출하여 클라이언트에 반송한다.  
그리고 서버에서도 똑같이 산출한 시퀀스 번호와 데이터를 보내면, 클라이언트에서 ACK 번호를 산출하여 서버에 반송한다.

TCP 에서는 이 방법으로 상대가 데이터를 받은 것을 확인한다.  
확인할 때까지 송신한 패킷을 송신용 버퍼 메모리에 저장해두고, 송신한 데이터에 대응하는 ACK 번호가  
반송되지 않는다면 패킷을 다시 송신한다.  
이 구조로 인해 네트워크의 어디에서 오류가 발생해도 전부 검출하여 회복 처리를 취할 수 있다.
하지만 TCP 가 아무리 다시 보내도 데이터가 도착하지 않는다면, 몇 번 다시 보낸 후 회복의 전망이  
없는것으로 보고 데이터 송신 동작을 강제로 종료하고 애플리케이션에 오류를 통지한다.

