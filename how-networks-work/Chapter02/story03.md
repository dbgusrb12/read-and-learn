# 데이터를 송/수신한다.

## 프로토콜 스택에 HTTP 리퀘스트 메시지를 넘긴다.

`connect`에서 애플리케이션에 제어가 되돌아오면 데이터 송/수신 동작에 들어간다.

프로토콜 스택에서는 받은 데이터를 곧바로 송신 하지 않고,  
자체 내부에 있는 송신용 버퍼 메모리 영역에 저장한 뒤 애플리케이션이 다음 데이터를 건네주기를 기다린다.  
이렇게 하는 이유는 프로토콜 스택에 건네주는 데이터의 길이가 애플리케이션의 종류나 만드는 방법에 따라 다르기 때문이다.

데이터를 한꺼번에 전부 송신 의뢰하는 경우도 있고, 1바이트나 1행씩 세분하여 송신 의뢰하는 경우도 있는데,  
프로토콜 스택에서 결정하거나 제어 할 수 없기 때문에 받은 데이터를 곧바로 보내면 작은 패킷을 여러번 보내야  
하는 상황이 생기고, 네트워크 이용 효율이 저하되는 문제가 있기 때문에 어느 정도 데이터를 저장하고 나서  
송/수신 동작을 실행한다.

어느 정도까지 데이터를 저장한 후 송신할지에 대한 판단 요소는 OS의 종류나 버전에 따라 다르지만,  
다음과 같은 요소를 바탕으로 판단한다.

### 한 패킷의 저장할 수 있는 데이터의 크기

프로토콜 스택은 `MTU`라는 매개변수를 바탕으로 판단한다.

`MTU`는 한 패킷으로 운반할 수 있는 디지털 데이터의 최대 길이로, 이더넷 기준으로는 보통  
1500바이트이다.

`MTU` 에는 패킷의 맨 앞부분에 헤더가 포함되어 있기 때문에, 헤더를 제외한 것이 하나의 패킷으로 운반할 수 있는  
데이터의 최대 길이가 되고, 이걸 `MSS` 라고 한다.

애플리케이션에서 받은 데이터가 `MSS`를 초과하거나 `MSS`에 가까운 길이에 이르기까지  
데이터를 저장하고 송신 동작을 하면 패킷이 잘게 나누어질 걱정을 할 필요가 없다.

### 타이밍

애플리케이션의 송신 속도가 느려지는 경우 `MSS` 에 가깝게 데이터를 저장하면 여기에서 시간이 걸려  
송신 동작이 지연되기 때문에 버퍼에 데이터가 모이지 않아도 적당한 곳에서 송신동작을 실행해야 되는데,  
이 기준은 프로토콜 스택 내부에 타이머이다.

이 타이머가 돌고, 일정 시간 이상 경과하면 패킷을 송신한다.

이 두가지 사항은 프로토콜 스택 내부의 동작들이고, 개발자가 원한다면 애플리케이션측에서  
송신 타이밍을 제어 할 수도 있다.

데이터 송신을 의뢰할 때 옵션을 지정 할 수 있으면, 버퍼에 머물지 않고 바로 송신 할 수도 있다.

## 데이터가 클 때는 분할하여 보낸다.

애플리케이션에서 보내준 데이터가 `MSS`의 길이를 초과할 경우, 프로토콜 스택에서는  
`MSS`의 길이에 맞게 데이터를 분할하여 한 개씩 패킷에 넣어 송신한다.

## ACK 번호를 사용하여 패킷이 도착했는지 확인한다.

송신쪽 TCP 담당 부분은 데이터를 분할 할 때 통신 개시부터 몇번째 바이트에 해당하는지 세어둔 뒤,  
분할 된 데이터를 송신할 때 세어둔 값을 TCP 헤더의 시퀀스 번호라는 필드에 담는다.

수신측에서는 패킷 전체 길이에서 헤더 길이를 빼면 데이터의 크기를 계산할 수 있기 때문에  
데이터의 크기는 헤더에 담지 않는다.

수신측에서는 송신측에서 보낸 헤더에 시퀀스 번호를 읽고, 데이터의 크기를 계산한 뒤  
패킷이 누락되었는지 확인하고, 누락이 없는 것을 확인하면 몇번째 바이트까지 수신받았는지를  
ACK 번호에 기록하여 송신측에 전달한다.

이 ACK 번호를 되돌려주는 동작을 `수신 확인 응답` 이라고 부르며, 송신측은 이것을 통해  
상대가 어디까지 수신했는지 파악한다.

시퀀스 번호는 1부터 시작하지 않고, 난수를 바탕으로 산출한 초기값으로 시작을 한다.  
그 이유는 1부터 시작한다면 악의적인 공격을 대비하기 어렵기 때문이다.  
하지만 시퀀스 번호가 항상 변하면 수신측에서 대응 할 수 없기 떄문에 송/수신을 시작하기 전에  
(`SYN` 을 1로 설정할 때) 초기값을 미리 상대에서 알리게 되어있다.

이렇게 시퀀스 번호와 ACK 번호를 사용하여 확인 하는 방법이 있는데,  
양방향 통신일 경우도 마찬가지다.

먼저 클라이언트에서 시퀀스 번호 초기값을 서버에 통지하고, 서버는 초기값 받은 것을 반송해  
초기값을 세팅한다.  
그 후 클라이언트에서 산출한 시퀀스 번호와 데이터를 보내고, 서버에서는 ACK 번호를 산출하여 클라이언트에 반송한다.  
그리고 서버에서도 똑같이 산출한 시퀀스 번호와 데이터를 보내면, 클라이언트에서 ACK 번호를 산출하여 서버에 반송한다.

TCP 에서는 이 방법으로 상대가 데이터를 받은 것을 확인한다.  
확인할 때까지 송신한 패킷을 송신용 버퍼 메모리에 저장해두고, 송신한 데이터에 대응하는 ACK 번호가  
반송되지 않는다면 패킷을 다시 송신한다.  
이 구조로 인해 네트워크의 어디에서 오류가 발생해도 전부 검출하여 회복 처리를 취할 수 있다.
하지만 TCP 가 아무리 다시 보내도 데이터가 도착하지 않는다면, 몇 번 다시 보낸 후 회복의 전망이  
없는것으로 보고 데이터 송신 동작을 강제로 종료하고 애플리케이션에 오류를 통지한다.

## 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다.

ACK 번호가 돌아오는 것을 기다리는 시간을 `타임아웃 값` 이라고 한다.

이 대기 시간은 적절하게 설정해야 하는데, 서버의 거리가 얼마나 되는지, 혹은 네트워크 정체 시 지연도 고려하여 설정해야 되기 때문에   
까다롭다.

그래서 TCP 는 대기 시간을 동적으로 변경하는 방법을 취하고 있는데, 그 방법은 ACK 번호가 돌아오는 시간을 기준으로 한다.

항상 ACK 번호가 돌아오는 시간을 계측해 두고, 돌아오는 시간이 지연되면 대기 시간을 늘리고, 바로 돌아오면 대기 시간을 짧게 설정한다.

## 윈도우 제어 방식으로 효율적으로 ACK 번호를 관리한다.

하나의 패킷을 보내고 ACK 번호를 기다리는 동안 아무 일도 하지 않고 기다리는건 시간 낭비이기 때문에 TCP는 윈도우 제어라는 방식을 사용한다.

윈도우 제어는 하나의 패킷을 보낸 후 기다리지 않고 차례대로 연속해서 복수의 패킷을 보내는 방법이다.

하지만 핑퐁 방식이라면 수신 처리가 끝난 후 ACK 를 돌려보내고 송신측에서는 해당 ACK 번호를 받은 뒤에 다음 패킷을 보내기 떄문에  
수신측의 능력을 초과하여 패킷을 보내는 일이 없는데, 윈도우 제어 방식으로 여러개를 보내버리면 수신측의 능력을 초과하여 패킷을 보내는 사태가  
일어날 수도 있다.

수신측에서 ACK 번호를 계산하거나 조각을 연결해 원래 데이터를 복원 하고 애플리케이션에 건네주어야 하는데,  
처리가 끝나지 않은 상태에서 다음 패킷이 도착해도 무관하도록 수신측 TCP 는 패킷을 수신하면 수신용 버퍼 메모리에 데이터를 임시 보관 한다.

하지만 애플리케이션에 건네주는 속도보다 다음 패킷이 도착하는 속도가 더 빠르다면, 수신 버퍼에 데이터가 넘쳐버린다.
넘친 데이터는 사라져 버리고, 그렇게 되면 패킷이 도착해도 오류가 발생한 것처럼 되버리고 만다.

이와 같은 상황을 방지하기 위해선, 먼저 수신측에서 송신측에 수신 가능한 데이터양을 통지하고, 송신측은 이 양을 초과하지 않도록 송신 동작을  
실행하면 된다.  
이것이 곧 윈도우 제어 방식의 개념이다.

수신측은 수신 버퍼에 데이터를 담고, 수신 처리를 진행 한 뒤, 수신 버퍼에 빈 부분이 생기면 해당 부분만큼 수신할 수 있는 데이터 양을 늘리고,  
TCP 헤더의 `윈도우 필드` 에 담아 송신측에 알린다. 이렇게 되면 수신측의 능력을 초과하여 데이터를 보내는 상황은 일어나지 않는다.  
수신 가능한 데이터 양의 최대값을 `윈도우 사이즈` 라고 부르며, TCP 를 정밀 조정하는 매개변수의 하나이다.

## ACK 번호와 윈도우를 합승한다.

ACK 번호는 수신측에서 데이터를 받았을 때 내용을 조사하여 정상 수신을 확인할 수 있는 경우에만 송신측에 보내고,  
윈도우 필드가 통지되는 시점은 수신측이 수신 버퍼에서 데이터를 추출하여 애플리케이션에 건네주었을 때이다.

위의 정보를 토대로 흐름을 본다면,  
송신측에서 데이터를 보내 수신측에 도착하고, 수신 동작이 정상적으로 완료되었을 때 ACK 번호를 송신측에 통지한 뒤,  
데이터를 애플리케이션에 건네주었을 때 윈도우를 송신측에 통지하는 상태가 된다.  
이렇게 되면 ACK 번호와 윈도우를 통지하는 패킷이 각각 따로 송신측에 보내지기 때문에 효율성이 저하된다.

그렇기 때문에 수신측은 ACK 번호나 윈도우를 통지할 때 소켓을 바로 보내지 않고 잠시 기다렸다가 다음 통지 동작이 일어나면   
양쪽을 상승시켜 한 개의 패킷으로 묶어서 보내는 방식으로 패킷의 수를 줄일 수 있고,  
복수의 ACK 번호 통지가 연속해서 일어나는 경우에도 마지막의 ACK 번호만 통지하여 패킷의 수를 줄일 수 있다.

## HTTP 응답 메시지를 수신한다.

브라우저는 리퀘스트 메시지를 송신해 달라고 의뢰를 하고, 이 과정이 끝나면 서버에서 돌아오는 응답 메시지를 받기 위해  
`read` 를 사용한다.

그러면 `read` 를 경유하여 프로토콜 스택에서 데이터를 송신할 때와 마찬가지로 임시로 보관할 수 있는 수신 버퍼를 사용한다.

프로토콜 스택은 수신 버퍼에서 수신 데이터를 추출하여 애플리케이션에 건네주는데, 만약 리퀘스트 메시지를 송신한지 얼마 안 된 시점이라면  
응답 메시지가 돌아오지 않았을 수도 있다.  
그 때 프로토콜 스택은 수신 버퍼에서 수신 데이터를 꺼내 애플리케이션에 건네주는 작업을 잠시 보류하고, 응답 메시지 패킷이 도착 했을 때  
작업을 재개한다.

프로토콜 스택이 데이터를 수신하는 동작은 다음과 같다.  
수신한 데이터 조각과 TCP 헤더의 내용을 조사하여 도중에 데이터가 누락되었는지 검사 한 후, 문제가 없으면 ACK 번호를 반송한다.  
그리고 데이터 조각을 수신 버퍼에 일시 보관하고, 조각을 연결하여 데이터를 원복한 뒤 애플리케이션이 지정한 메모리 영역에 옮겨 기록한 후  
애플리케이션에 제어를 되돌려준다.  
애플리케이션에 데이터를 건네준 후에 타이밍을 가늠하여 윈도우를 송신측에 통지한다.